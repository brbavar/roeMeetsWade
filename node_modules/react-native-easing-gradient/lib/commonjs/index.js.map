{"version":3,"sources":["index.ts"],"names":["easeInOut","Easing","bezier","easeGradient","colorStops","easing","extraColorStopsPerTransition","colors","locations","initialLocations","Object","keys","map","key","Number","sort","totalColorStops","length","currentStopIndex","startLocation","endLocation","startColor","color","endColor","currentEasing","colorScale","inputRange","outputRange","currentTransitionLength","stepSize","stepIndex","progress","push"],"mappings":";;;;;;;AAAA;;AACA;;AAeA,MAAMA,SAAS,GAAGC,oBAAOC,MAAP,CAAc,IAAd,EAAoB,CAApB,EAAuB,IAAvB,EAA6B,CAA7B,CAAlB;;AAEA,SAASC,YAAT,CAAsB;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,MAAM,GAAGL,SAAvB;AAAkCM,EAAAA,4BAA4B,GAAG;AAAjE,CAAtB,EAA6G;AAC3G,QAAMC,MAAgB,GAAG,EAAzB;AACA,QAAMC,SAAmB,GAAG,EAA5B;AAEA,QAAMC,gBAAgB,GAAGC,MAAM,CAACC,IAAP,CAAYP,UAAZ,EACtBQ,GADsB,CACjBC,GAAD,IAASC,MAAM,CAACD,GAAD,CADG,EAEtBE,IAFsB,EAAzB;AAIA,QAAMC,eAAe,GAAGP,gBAAgB,CAACQ,MAAzC;;AAEA,OACE,IAAIC,gBAAgB,GAAG,CADzB,EAEEA,gBAAgB,GAAGF,eAAe,GAAG,CAFvC,EAGEE,gBAAgB,EAHlB,EAIE;AAAA;;AACA,UAAMC,aAAa,GAAGV,gBAAgB,CAACS,gBAAD,CAAtC;AACA,UAAME,WAAW,GAAGX,gBAAgB,CAACS,gBAAgB,GAAG,CAApB,CAApC;AAEA,UAAMG,UAAU,GAAGjB,UAAU,CAACe,aAAD,CAAV,CAA0BG,KAA7C;AACA,UAAMC,QAAQ,GAAGnB,UAAU,CAACgB,WAAD,CAAV,CAAwBE,KAAzC;AACA,UAAME,aAAa,4BAAGpB,UAAU,CAACe,aAAD,CAAV,CAA0Bd,MAA7B,yEAAuCA,MAA1D;AAEA,UAAMoB,UAAU,GAAG,8CAAoB;AACrCC,MAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,CADyB;AAErCC,MAAAA,WAAW,EAAE,CAACN,UAAD,EAAaE,QAAb,CAFwB;AAGrClB,MAAAA,MAAM,EAAEmB;AAH6B,KAApB,CAAnB;AAMA,UAAMI,uBAAuB,GAAGR,WAAW,GAAGD,aAA9C;AACA,UAAMU,QAAQ,GAAG,KAAKvB,4BAA4B,GAAG,CAApC,CAAjB;;AAEA,SACE,IAAIwB,SAAS,GAAG,CADlB,EAEEA,SAAS,IAAIxB,4BAA4B,GAAG,CAF9C,EAGEwB,SAAS,EAHX,EAIE;AACA,YAAMC,QAAQ,GAAGD,SAAS,GAAGD,QAA7B;AACA,YAAMP,KAAK,GAAGG,UAAU,CAACM,QAAD,CAAxB;AACAxB,MAAAA,MAAM,CAACyB,IAAP,CAAYV,KAAZ;AACAd,MAAAA,SAAS,CAACwB,IAAV,CAAeb,aAAa,GAAGS,uBAAuB,GAAGG,QAAzD;AACD;AACF;;AAED,SAAO;AAAExB,IAAAA,MAAF;AAAUC,IAAAA;AAAV,GAAP;AACD","sourcesContent":["import { Easing, EasingFunction } from 'react-native'\nimport { createInterpolation } from './create-interpolation'\n\ninterface ColorStops {\n  [location: number]: {\n    color: string\n    easing?: EasingFunction\n  }\n}\n\ninterface GradientParams {\n  colorStops: ColorStops\n  extraColorStopsPerTransition?: number\n  easing?: EasingFunction\n}\n\nconst easeInOut = Easing.bezier(0.42, 0, 0.58, 1)\n\nfunction easeGradient({ colorStops, easing = easeInOut, extraColorStopsPerTransition = 12 }: GradientParams) {\n  const colors: string[] = []\n  const locations: number[] = []\n\n  const initialLocations = Object.keys(colorStops)\n    .map((key) => Number(key))\n    .sort()\n\n  const totalColorStops = initialLocations.length\n\n  for (\n    let currentStopIndex = 0;\n    currentStopIndex < totalColorStops - 1;\n    currentStopIndex++\n  ) {\n    const startLocation = initialLocations[currentStopIndex]\n    const endLocation = initialLocations[currentStopIndex + 1]\n\n    const startColor = colorStops[startLocation].color\n    const endColor = colorStops[endLocation].color\n    const currentEasing = colorStops[startLocation].easing ?? easing\n\n    const colorScale = createInterpolation({\n      inputRange: [0, 1],\n      outputRange: [startColor, endColor],\n      easing: currentEasing,\n    })\n\n    const currentTransitionLength = endLocation - startLocation\n    const stepSize = 1 / (extraColorStopsPerTransition + 1)\n\n    for (\n      let stepIndex = 0;\n      stepIndex <= extraColorStopsPerTransition + 1;\n      stepIndex++\n    ) {\n      const progress = stepIndex * stepSize\n      const color = colorScale(progress)\n      colors.push(color)\n      locations.push(startLocation + currentTransitionLength * progress)\n    }\n  }\n\n  return { colors, locations }\n}\n\nexport { easeGradient }\n"]}